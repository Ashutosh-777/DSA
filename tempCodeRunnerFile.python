def format_amount_currency(amount, currency):
    try:
        amount = float(amount)
    except ValueError:
        return None  # Invalid amount

    divide_by_100_currencies = {"EUR", "USD", "SGD", "BRL"}
    multiply_by_1_currencies = {"JPY", "ISK", "KRW"}

    if currency in divide_by_100_currencies:
        amount = amount / 100
    elif currency in multiply_by_1_currencies:
        amount = amount * 1
    else:
        return None  # Invalid currency

    return f"{amount:.2f}{currency}"


def is_valid_row(amount, currency, evidence_due_by):
    valid_currencies = {"EUR", "USD", "SGD", "BRL", "JPY", "ISK", "KRW"}
    if currency not in valid_currencies:
        return False
    if not amount.isdigit():
        return False
    if not evidence_due_by.isdigit():
        return False
    return True


def parseNetworkChargebackInfo(rows):
    parsed_data = []
    header_mapping = {}
    current_bank = ""
    current_file_date = ""  # Store the current file's date
    txn_data = {}  # To store transactions and their status

    for row in rows:
        if ".csv" in row:  # Extract the bank name and file date from the file name
            current_bank = row.split('_')[0]  # Bank name (e.g., "VISA")
            current_file_date = row.split('_')[1].replace('.csv', '')  # File date (e.g., "20230602")
            continue
        elif 'transaction' in row.lower():  # Map headers dynamically
            headers = row.lower().split(',')
            for idx, column in enumerate(headers):
                header_mapping[column.strip()] = idx
            continue
        else:
            # Extract transaction details dynamically
            transaction_data = row.split(',')

            if len(transaction_data) >= len(header_mapping):
                txn_id = transaction_data[header_mapping.get('transaction')].strip() if 'transaction' in header_mapping else ''
                merchant_id = transaction_data[header_mapping.get('merchant')].strip() if 'merchant' in header_mapping else ''
                amount = transaction_data[header_mapping.get('amount')].strip() if 'amount' in header_mapping else ''
                currency = transaction_data[header_mapping.get('currency')].strip() if 'currency' in header_mapping else ''
                evidence_due_by = transaction_data[header_mapping.get('evidence_due_by')].strip() if 'evidence_due_by' in header_mapping else ''
                reason = transaction_data[header_mapping.get('reason')].strip().lower() if 'reason' in header_mapping else ''

                # Validate the row
                if not is_valid_row(amount, currency, evidence_due_by):
                    continue  # Ignore invalid rows

                # Full transaction ID with bank name and date (to track by file)
                full_txn_id = f"{current_bank}_{txn_id}"
                
                # Track transactions that are not marked as "withdrawn"
                if reason != 'withdrawn':
                    txn_data[full_txn_id] = {
                        'merchant_id': merchant_id,
                        'amount_with_currency': format_amount_currency(amount, currency),
                        'evidence_due_by': evidence_due_by,
                        'is_withdrawn': False,
                        'file_date': current_file_date  # Track the file date
                    }
                else:
                    # Handle 'withdrawn' rows
                    if full_txn_id in txn_data:
                        # Withdraw the row only if the withdrawal is from a later file
                        if txn_data[full_txn_id]['file_date'] < current_file_date:
                            txn_data[full_txn_id]['is_withdrawn'] = True

    # Prepare the final parsed data, excluding withdrawn transactions
    for txn_id, txn_info in txn_data.items():
        if not txn_info['is_withdrawn']:  # Only include non-withdrawn rows
            parsed_data.append(f"{txn_id},{txn_info['merchant_id']},{txn_info['amount_with_currency']},{txn_info['evidence_due_by']}")

    return "\n".join(parsed_data)


def main():
    # Example input rows with some transactions marked as "withdrawn"
    rows = [
        "VISA_20230602.csv",
        "transaction,merchant,amount,currency,evidence_due_by,reason",
        "123890132,47821,37906,USD,1686812400,fraudulent",   # Valid row
        "110450953,63724,12750,JPY,1686898800,duplicate",    # Valid row
        "MASTERCARD_20230601.csv",
        "transaction,merchant,currency,amount,evidence_due_by,reason",
        "110450953,63724,JPY,12750,1686898800,withdrawn",    # Withdrawn in a different file, should remove both
        "VISA_20230603.csv",
        "transaction,merchant,amount,currency,evidence_due_by,reason",
        "123890132,47821,37906,USD,1686812400,withdrawn",    # Withdrawn in a later file, should remove both rows with txn_id=123890132
    ]

    # Parse the network chargeback info
    parsed_info = parseNetworkChargebackInfo(rows)

    # Print the parsed data
    print("Parsed Network Chargeback Information:")
    print(parsed_info)


# Run the main function when the script is executed
if __name__ == "__main__":
    main()
